## ポケモンデータ不整合デバッグ TODO (メガリザードンXのケース)

### 1. 原因分析と仮説
- **現状**: 「ほのお・ドラゴン」タイプであるメガリザードンXがDB検索でヒットしない。
- **データソース**: ポケモンWikiの表において、メガシンカのデータがどのように記載されているか（別行か、注釈か）。
- **パースロジック**: `scripts/fetch_pokemons.ts` の `parsePokemons` 関数がメガシンカの名称（例: `リザードン(メガリザードンX)`）とタイプを正しく抽出できているか。特に名前のクリーニング処理。
- **DB登録ロジック**: `national_no` が `UNIQUE` 制約を持つため、同一図鑑番号の別フォルム（メガシンカ等）がどのように処理されているか。`upsert` の `onConflict` および `ignoreDuplicates` の挙動確認。
- **仮説**: 
    1. メガシンカの行がパース時にスキップされている。
    2. 名前が `リザードン(メガリザードンX)` のように括弧付きで登録されており、検索時の `name_ja = 'リザードン'` と一致していない。
    3. 同一 `national_no` のため、基本形のリザードンでメガリザードンXのデータが上書きされているか、無視されている。

### 2. デバッグ手順
1.  [ ] **データソースの目視確認**:
    *   ポケモンWikiの `0006 リザードン` の項目を確認し、メガリザードンXのタイプ表記が「ほのお・ドラゴン」であり、テーブルのどのセルに対応するかを正確に把握する。
    *   HTMLソースも確認し、`<td>` タグの内容をコピーしておく。
2.  [ ] **`parsePokemons` 関数の限定テスト**:
    *   `fetch_pokemons.ts` を一時的に変更し、`リザードン` (national_no: 6) の行データだけを処理するように `console.log` を仕込んで実行する。
    *   具体的には、`rows.each` の中で `national_no` が `6` の場合のみ詳細なログ（抽出した `national_no`, `name_ja`, `type_1`, `type_2`）を出力する。
    *   特にメガリザードンXに該当する行がどのようにパースされているか（名前の括弧部分の扱いやタイプの取得状況）を確認する。
    *   必要であれば、テスト用の短いHTMLスニペットをスクリプトに直接埋め込み、`cheerio.load()` に渡してパースの挙動を単体でテストする。
3.  [ ] **DB登録データの確認**:
    *   `docker exec supabase_db_pokemon_mcp psql -U postgres -c "SELECT * FROM pokemons WHERE national_no = 6;"` を実行し、現在DBに格納されているリザードンのデータを確認する。
    *   メガシンカのデータがどのように格納されているか（あるいはされていないか）を確認。

### 3. 改修方針の検討
- **方針A: メガシンカも別レコードとして登録 (ただし national_no の UNIQUE 制約に抵触)**
    - スキーマ変更（`national_no` と `form_name` 等の複合主キーにするなど）が必要になり、影響が大きい。今回は見送る。
- **方針B: メガシンカのデータを優先して登録、または特定のメガシンカのタイプを採用**
    - Wikiに複数のメガシンカがある場合、どれを「代表」とするか定義が必要。
- **方針C: 名前にフォルム情報を含めて登録し、検索側で対応 (例: `name_ja` = 'リザードン (メガリザードンX)')**
    - これが一番現実的か。パース時に名前を `図鑑名(フォルム名)` のように整形する。
    - ただし、自然言語検索時に「リザードン」でメガリザードンXもヒットさせるには、MCP側のプロンプトやLLMの解釈、あるいはDB検索時の `LIKE` 句などでの工夫が必要になる。
- **方針D (今回の暫定対応): スクリプトで特定のメガシンカ（例: メガリザードンX）のデータを見つけたら、それを基本形のリザードンのタイプとしてDBに登録する。**
    - `parsePokemons` で、もし「リザードン(メガリザードンX)」の行を見つけたら、そのタイプ情報を `national_no = 6` のポケモンのタイプとして優先的に採用する。
    - これにより、`pokemons` テーブルの `national_no = 6` のレコードは、「ほのお・ドラゴン」になる。
    - ただし、これはあくまでメガリザードンXのタイプを基本形に「上書き」する形であり、他のメガシンカやフォルムチェンジには対応できない一時的な対応。

### 4. `fetch_pokemons.ts` の改修 (方針Dを採用する場合)
1.  [X] `parsePokemons` 関数を修正:
    *   [X] ループ処理中、`national_no` が `6` のポケモン（リザードン）のデータを処理する際に特別な条件分岐を追加。
    *   [X] もし `$(cells[1]).text().trim()` が `リザードン(メガリザードンX)` という文字列に一致する場合、その行から取得したタイプ1 (`ほのお`) とタイプ2 (`ドラゴン`) を、`national_no = 6` のポケモンのタイプとして優先的に採用する。
    *   [X] 通常の「リザードン」の行や「メガリザードンY」の行は、この特別な処理ではタイプを採用しない（あるいは `seenInThisFetch` で後から処理されるメガXに上書きされる形でも良い）。
    *   [X] パースしたポケモン名のリストから、`name_ja` が `リザードン(メガリザードンX)` などとなっているものを、DB登録前に `リザードン` に統一する（または `リザードン` のレコードにタイプ情報をマージする）。現状は `upsert` で `national_no` がキーなので、名前の正規化は必須ではないが、検索時のことを考えると統一が望ましい。
    *   [X] 今回は、`national_no = 6` で `リザードン(メガリザードンX)` が見つかったら、そのタイプを `national_no = 6` の基本情報として`pokemons`配列に格納する。（他のリザードンのフォルムは無視または上書きされる形）
2.  [X] データベースのリセットと再取得:
    *   [X] `supabase db reset --no-seed` でDBをクリア。
    *   [X] 改修した `npx ts-node scripts/fetch_pokemons.ts` を実行して全データ(1-400)を再取得。

### 5. 結果確認
1.  [X] `docker exec supabase_db_pokemon_mcp psql -U postgres -c "SELECT * FROM pokemons WHERE national_no = 6;"` を実行し、リザードンのタイプが「ほのお・ドラゴン」になっていることを確認。
2.  [X] MCP経由で「ほのお ドラゴンのポケモン」を検索し、リザードンがヒットすることを確認。

---
**デバッグログ・メモエリア:**
